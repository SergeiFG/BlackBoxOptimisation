Этот проект представляет собой gRPC-сервер и клиент для управления сессиями оптимизации. Сервер сохраняет данные в памяти и создаёт текстовые файлы с данными сессии оптимизации. Клиент позволяет интерактивно управлять сессиями: создавать, оптимизировать, останавливать и удалять их.

Используемые библиотеки
Для работы проекта используются следующие библиотеки:

grpc: Для реализации gRPC-сервера и клиента.

concurrent.futures: Для многопоточной обработки запросов на сервере.

os: Для работы с файловой системой (создание и удаление файлов).

traceback: Для обработки и вывода ошибок.

threading: Для реализации параллельного выполнения задач

Установка и запуск

Для .exe файлов:

### На данный момент исполняемые файлы не реботоспособны, пересборка делается после каждого обновления клиента и сервера. Однако алгоритм сохраняется ###

### На данный момент, необходима будет предварительная установка глобальных библиотек, как для запуска через терминал ###
 
Запустите сначала server, затем client, находящиеся в папке проекта. Проект начнет работу.

При запуске вручную через терминал:

Установите зависимости:
Убедитесь, что у вас установлены необходимые библиотеки. Если нет, установите их с помощью pip:

pip install grpcio grpcio-tools

Запуск сервера:
Откройте терминал и запустите сервер:

python server.py

Сервер начнёт слушать на порту 5081.

Запуск клиента:
Откройте второй терминал и запустите клиент:

python client.py

Работа с клиентом
После запуска клиента появится меню с выбором методов:

Available methods:
1. StartOptimizeSession
2. OptimizeIteration
3. Stop
4. Pause

Используемые форматы:

optimization_instance_id - str // ID сессии
CV, MV tags - TagType, имеющая, согласно proto, следующую структуру:
	string id = 1;
	string name = 2;
 	string dataType = 3;     // Тип данных (Integer, Numeric, Bool)
 	double lower_bound = 4;  // Нижняя граница значения
 	double upper_bound = 5;  // Верхняя граница значения
Значение целевой функции - int
maxIterations - int
modelId - str

1. Метод StartOptimizeSession (инициализация)

Перечень входных параметров задается в следующем виде: 
	cvs=cvs,
	mvs=mvs,
	maximize=False,  # Минимизируем целевую функцию
	max_iterations=10  # 10 итераций метода
При этом сами cv, mv задаются в соответствии со своим типом дынных, устанавливаются значения в рабочей точки (для инициализации)

При инициализации данные сессии сохраняются в памяти сервера, ответом является id сессии оптимизации

Вы можете вызвать StartOptimizeSession несколько раз подряд, чтобы создать несколько сессий.

2. Метод OptimizeIteration

Первичное обращение для отработки первой итерации происходит по id сессии

В последующих итерациях перечнем входных параметров также являются: CV, значение целевой функции для запрошенных MV. Сами подаваемые данные имеют структуру TagVal, определяемую в proto следующим образом:

	string tagId = 1;        // Идентификатор тега (GUID)
 	uint64 timeStamp = 2;    // Временная метка
 	double numericValue = 3; // Числовое значение
 	bool isGood = 4;         // Флаг корректности значения

Обращение к конкретной сессии осуществляется с помощью идентификатора optimization_instance_id

Возможен запуск нескольких потоков оптимизации параллельно.

3. Метод Stop

Обращение к конкретной сессии осуществляется с помощью идентификатора optimization_instance_id

Данные выбранной сессии будут удалены из памяти.

Текстовый файл, соответствующий сессии, будет удалён. Получаемым является только сообщение о результате (прекращении сессии) в формате строки

4. Метод Pause

Обращение к конкретной сессии осуществляется с помощью идентификатора optimization_instance_id

Оптимизация останавливается после достигнутой итерации и остается в памяти

Возвращается сообщение о результате (строка) и флаг успешной паузы


6. Также необходима реализация на стороне сервера DataProcessing метода CalculateCV, принимающего идентификатор сессии, идентификатор модели, и значения MV в заданном формате

Результатом работы метода должен быть ответ, содержащий: идентификатор сессии, новые значения CV


Новая функция статуса сервиса:


1.Принцип работы:

Клиент отправляет запрос ArgRequest (пока только с пустым accessToken)

Сервер возвращает ответ ServiceStatus с фиксированными значениями:

return RtoApi_pb2.ServiceStatus(
    serviceId="",
    status="Running",
    serviceType="RtoService", 
    user="",
    message=""
)


2.Где реализовано:


В серверном коде как метод класса RtoServiceServicer


3.Зачем нужна эта функция:

Health-check:

Позволяет клиентам проверять, жив ли сервер

Аналог "пингования" сервиса


4.Базовый мониторинг:

Можно определить тип сервиса (RtoService)

Видеть его текущее состояние (Running/Stopped)


5.Расширяемость:

Поле serviceId можно использовать для кластеров

user - для аутентифицированных сессий

message - для передачи служебной информации


6.Интеграция:

Стандартная практика в микросервисной архитектуре

Позволяет оркестраторам (Kubernetes) проверять состояние сервиса
